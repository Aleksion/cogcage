# TASK-001: MatchEngine Durable Object

## Context
The Molt Pit (themoltpit.com) is an AI agent battle arena. Players configure LLM agents and fight in real-time matches.

The core thesis: engine ticks at fixed rate (200ms), agents push actions to a queue, latency IS the skill expression.
See: docs/architecture-game-engine.md and docs/tasks/task-001-match-engine-do.md

## Cloudflare Account
- Account ID: b83dbb4965b4cead1bfdba697e1a137b
- Email: aleks@precurion.com
- wrangler is logged in and ready

## Your Job
Build the `engine/` directory in this repo — a Cloudflare Workers Durable Object that IS the game engine.

## File Structure to Create
```
engine/
├── wrangler.toml
├── package.json
├── tsconfig.json
└── src/
    ├── index.ts          ← Worker entrypoint, routes /match/:id/* to DO
    ├── MatchEngine.ts    ← The Durable Object
    ├── game/
    │   ├── engine.ts     ← Deterministic tick logic (port relevant parts from web/src/lib/ws2/)
    │   ├── types.ts      ← GameState, Action, BotConfig types
    │   └── constants.ts  ← TICK_MS=200, MAX_QUEUE_DEPTH=5, MATCH_TIMEOUT_MS
    └── auth.ts           ← Token validation helper
```

## MatchEngine DO Requirements

### Routes (handled in fetch())
- `GET /match/:id` — WebSocket upgrade for spectators/agent plugins
- `POST /match/:id/start` — Start match (called from Vercel lobby API)
- `POST /match/:id/queue` — Push action from agent plugin
- `GET /match/:id/state` — Snapshot of current game state (HTTP polling fallback)
- `GET /health` — Health check

### WebSocket protocol
- On connect: send `{ type: "connected", botId, matchId, tick: currentTick }`
- On each alarm: broadcast `{ type: "tick", state: GameState, tick: number }`
- On match end: broadcast `{ type: "match_complete", result: MatchResult }`

### Tick loop (alarm())
```typescript
async alarm() {
  if (!this.matchState || this.matchState.over) return;
  
  // 1. Pop one action per bot (or NO_OP if empty)
  // 2. advanceTick(state, actions) → new state
  // 3. Persist tick to SQLite: key=`tick:${n}`, value=JSON
  // 4. Broadcast to all WebSocket connections
  // 5. Schedule next alarm: Date.now() + TICK_MS
  // 6. If match over: emit complete event, stop
}
```

### start() handler
- Accepts: `{ botA: BotConfig, botB: BotConfig, seed: number }`
- Initializes game state with spawn positions (6,10) and (14,10)
- Sets alarm for first tick: `this.state.storage.setAlarm(Date.now() + TICK_MS)`
- Returns: `{ matchId, ok: true }`

### queue() handler  
- Validates auth token → gets botId
- Pushes action to `this.queues.get(botId)` array
- Rejects if queue depth > MAX_QUEUE_DEPTH (anti-spam)
- Returns: `{ ok: true, queueDepth: number }`

### Auth
- Simple shared secret for Vercel→DO calls: check `Authorization: Bearer ${COGCAGE_ENGINE_SECRET}` header
- Per-player tokens for plugin connections: stored in DO state, generated by Vercel `/api/player/token`
- For now: accept any non-empty token (we'll tighten auth in Phase 3)

## Game Logic (port from web/src/lib/ws2/)
Look at: `web/src/lib/ws2/engine.js` and `web/src/lib/ws2/match-runner.ts`
Port the core advanceTick logic into `engine/src/game/engine.ts` as TypeScript.
Key mechanics: HP, energy, positions, action resolution, win condition (HP <= 0).

## wrangler.toml
```toml
name = "themoltpit-engine"
main = "src/index.ts"
compatibility_date = "2026-02-27"
account_id = "b83dbb4965b4cead1bfdba697e1a137b"

[[durable_objects.bindings]]
name = "MATCH"
class_name = "MatchEngine"

[[migrations]]
tag = "v1"
new_sqlite_classes = ["MatchEngine"]
```

## Deploy
After building and verifying types compile:
```bash
cd engine/
npm install
wrangler deploy
```

Then test:
```bash
curl https://themoltpit-engine.aleks-precurion.workers.dev/health
```

Note: DNS route for engine.themoltpit.com is a follow-up — deploy to workers.dev subdomain first.

## Definition of Done
1. `wrangler deploy` succeeds
2. `curl .../health` → `{ ok: true }`
3. TypeScript compiles clean (no errors)
4. MatchEngine DO class has: alarm(), fetch(), handleWebSocket(), handleStart(), handleQueuePush()
5. advanceTick() function ported and working
6. Commit everything to feat/engine-do branch
7. Open PR against main

## Notes
- Use `new_sqlite_classes` (not `new_classes`) — SQLite-backed DOs are GA
- WebSocket hibernation: use `this.state.acceptWebSocket(server)` not just `new WebSocketPair()`
- Don't worry about Vercel Queues integration yet — that's TASK-002. DO operates standalone first.
- No Electric Durable Streams in this task — that's plugin side.
